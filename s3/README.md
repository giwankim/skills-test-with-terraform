# Comparison: `with/` vs `without/` Terraform S3 Modules

Both implementations create a reusable S3 bucket module with encryption, versioning, public access blocking, and lifecycle management. They share secure-by-default posture and the `"this"` resource naming convention. The differences reveal distinct design philosophies.

- `with/` was generated with the assistance of Claude Code skills (terraform-skill, terraform-style-guide, terraform-test)
- `without/` was generated by Claude Code without any skills

---

## Structure

| Aspect | `with/` | `without/` |
|--------|---------|------------|
| Layout | `modules/s3-bucket/` subdirectory | Root-level module |
| Examples | `examples/minimal/`, `examples/complete/` | `examples/minimal/`, `examples/full/` |
| Tests | `tests/s3_bucket.tftest.hcl` (1 file, 12 runs) | `tests/defaults.tftest.hcl` + `tests/plan_mock.tftest.hcl` (2 files, 5 runs) |
| CI/CD | None | `.github/workflows/ci.yml` |
| Linting | None | `.tflint.hcl` (aws ruleset) |
| Lock file | None | `.terraform.lock.hcl` committed |
| `.gitignore` | None | Present |

**Best-practice edge: `without/`** - CI pipeline with fmt/validate/test/lint stages matches all three guides' emphasis on automated static analysis. The `with/` module has no CI or linting at all.

---

## Variable Design

| Aspect | `with/` | `without/` |
|--------|---------|------------|
| Required vars | None (all have defaults) | `name_prefix` (required, validated) |
| Naming scheme | `bucket_name` / `bucket_prefix` (mutually exclusive) | `name_prefix` + optional `bucket_name` override |
| Auto-naming | AWS-generated via `bucket_prefix` | `random_string` suffix: `${name_prefix}-${random_suffix}` |
| Bucket key | `bucket_key_enabled` var exposed | Not exposed |
| Public access toggle | `block_public_access` bool | Not toggleable (always on) |
| Lifecycle config | Fully generic `lifecycle_rules` list(object) | Single-purpose `noncurrent_version_expiration_days` number |
| Logging | `logging_target_bucket` + `logging_target_prefix` | Not supported |
| KMS var name | `kms_master_key_id` | `kms_key_arn` |
| Input validation | SSE algorithm only | SSE algorithm + `name_prefix` regex + length |
| Cross-var validation | None | `check` block: KMS key required when using `aws:kms` |

**Best-practice edge: mixed.**
- `without/` is stronger on validation (input constraints + cross-variable `check` block). AWS and Google guides emphasize validation at system boundaries.
- `without/` forces a `name_prefix` which enables a consistent naming/tagging convention throughout.
- `with/` provides more flexibility (logging, flexible lifecycle rules, public access toggle, bucket key), but at the cost of a larger API surface. Some of this (like disabling public access blocking) arguably weakens security posture.
- `without/` naming `kms_key_arn` is clearer than `with/`'s `kms_master_key_id` (which matches the AWS API field name but is less intuitive).

---

## Resource Implementation

| Aspect | `with/` | `without/` |
|--------|---------|------------|
| Resources | 6 (bucket, versioning, SSE, public access, lifecycle, logging) | 6 (random_string, bucket, SSE, public access, versioning, lifecycle) |
| Public access block | Conditional (`count`) | Always created |
| Lifecycle rules | Dynamic blocks, multi-rule, transitions+expiration+prefix filter | Single hardcoded rule for noncurrent version expiration |
| Lifecycle filter | Dynamic - **missing `filter {}` when prefix is null** | Empty `filter {}` always present |
| Tagging | Pass-through: `tags = var.tags` | Computed: `merge(common_tags, { Name = ... })` with `ManagedBy`+`Project` defaults |
| Bucket naming | Direct var assignment, ternary for prefix | Computed via `locals` with `coalesce`/`try` pattern |
| Locals | None | `name_prefix`, `common_tags`, `bucket_name` |

**Best-practice edge: `without/`** on tagging and naming; **`with/`** on lifecycle flexibility.
- Google and AWS guides recommend default tags (`ManagedBy`, project identifiers). `without/` does this automatically; `with/` delegates entirely to the caller, meaning tags are inconsistent unless every caller remembers.
- `with/` has a **bug**: lifecycle rules without a prefix produce no `filter {}` block, which triggers AWS provider warnings that will become errors (per AWS provider changelog). `without/` handles this correctly with an always-present empty `filter {}`.
- `without/`'s use of `locals` for computed values follows the Google guide's recommendation to use locals for derived values and keep resource blocks clean.

---

## Testing

| Aspect | `with/` (12 tests) | `without/` (5 tests) |
|--------|---------------------|----------------------|
| Mock setup | `mock_provider "aws" {}` (bare) | `mock_provider "aws" { mock_resource ... { defaults = {...} } }` |
| Test commands | Mix of `plan` and `apply` | `plan` only |
| Set-type handling | `alltrue([for rule in ... :])` | `one(resource[*].attribute)` |
| Negative testing | `expect_failures` for invalid SSE | None |
| Coverage | defaults, explicit naming, versioning, encryption, public access, lifecycle, tag propagation, validation | defaults, KMS, versioning, lifecycle presence/absence |
| Test file org | 1 file, 12 runs | 2 files, 5 runs total |

**Best-practice edge: `with/`** on coverage breadth; **`without/`** on set-type assertions.
- `with/` tests more scenarios including negative validation testing (`expect_failures`) and tag propagation.
- `without/` uses the correct `one()` + splat pattern for set-type block assertions. `with/` uses `[0]` indexing on `versioning_configuration` which works with mock providers but is technically incorrect for sets and would fail with real providers. The `alltrue([for ...])` workaround for SSE rules is verbose but correct.
- `without/` separates tests into logical files (defaults vs plan mocks), which scales better.

---

## Security Posture

| Aspect | `with/` | `without/` |
|--------|---------|------------|
| Public access | Defaults to blocked, but **can be disabled** | Always blocked, **cannot be disabled** |
| Encryption | Always on (AES256 default) | Always on (AES256 default) |
| Versioning | On by default, can disable | On by default, can disable |
| KMS validation | None (silently ignores missing key) | `check` block warns when KMS selected without key |
| Force destroy | Exposed, defaults false | Exposed, defaults false |

**Best-practice edge: `without/`** - Hardcoded public access blocking is more aligned with AWS security best practices. The `check` block for KMS validation prevents misconfiguration. `with/`'s ability to disable public access blocking is a risk surface.

---

## Findings Summary

### `without/` strengths (better architectural integrity)
1. **CI/CD pipeline** with fmt, validate, test, and lint stages
2. **Automatic tagging** with `ManagedBy` and `Project` defaults via `locals`
3. **Input validation** on `name_prefix` (regex + length) and cross-variable `check` block
4. **Correct lifecycle `filter {}`** - avoids provider warnings/errors
5. **Hardened security** - public access blocking cannot be disabled
6. **Correct set assertions** using `one()` + splat in tests
7. **Broader version constraint** (`>= 1.7.0, < 2.0.0`) is more flexible for consumers
8. **Linting** with tflint + AWS ruleset

### `with/` strengths (more features)
1. **Richer S3 feature set** - access logging, flexible lifecycle rules with transitions/prefix filters, bucket key support
2. **More thorough test coverage** - 12 tests including negative validation and tag propagation
3. **Better examples** - complete example demonstrates multi-module composition (log bucket + main bucket)
4. **Module subdirectory** allows housing multiple modules in the same repo

### `with/` issues
1. **Missing `filter {}` block** in lifecycle rules when no prefix is set - will cause provider errors
2. **Incorrect `[0]` indexing** on `versioning_configuration` set in tests (works with mocks, not semantically correct)
3. **No input validation** beyond SSE algorithm (no `name_prefix` equivalent, no cross-variable checks)
4. **No default tags** - tagging consistency depends entirely on callers
5. **Unused `random` provider** declared but never referenced in module code
6. **No CI/CD or linting** configuration
7. **Allows disabling public access** - unnecessary security risk surface

### `without/` issues
1. **Limited lifecycle rules** - only supports noncurrent version expiration (no transitions, prefix filters, or current version expiration)
2. **No access logging** support
3. **No bucket key** configuration for KMS cost optimization
4. **Fewer tests** - missing negative validation testing, tag propagation tests

---

## Verdict

**`without/` has stronger architectural integrity** as evaluated against the HashiCorp, AWS, and Google best-practice guides. Its opinionated defaults (forced naming convention, automatic tagging, hardened security, validated inputs, CI pipeline) align with all three guides' emphasis on governance, consistency, and automation. It trades flexibility for correctness.

**`with/` provides a more feature-complete S3 abstraction** but has several concrete bugs (missing `filter {}`, incorrect set indexing) and architectural gaps (no tagging defaults, no validation, no CI) that reduce its production-readiness.

An ideal module would combine `without/`'s governance patterns (validation, tagging, CI, security hardening) with `with/`'s feature coverage (logging, flexible lifecycle rules, comprehensive testing).
